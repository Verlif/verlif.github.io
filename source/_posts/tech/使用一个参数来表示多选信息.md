---
title: 使用一个参数来表示多选信息
tags:
  - Java
  - 小技巧
published: true
cover: /images/SGlkWgbGd.png
banner: /images/SGlkWgbGd.png
abbrlink: 45461
date: 2024-01-25 10:28:15
category:
	- 技术
---
在开发中我们总是能遇到多选的情形，尤其是在配置中。

一般情况下我们可以使用**一对多**的存储关系或是**append字符串**的方式将所有选择项记录下来。但是一对多的存储关系占用资源多，**append字符串**的解析成本高，有没有更优的方式呢？答案肯定是有的，就是用**位运算**。

我们先将解决思路细化：

1. 选择项其实就是**选择与未选择**，我们用`1`和`0`来表示
2. 不同的选择项我们用不同的标识来区分，比如序号`01234...`

这样我们其实就很明确了，有**序号**，有`01`，那么我们直接用**字节**存储选项值就非常合适。

## 位存储

首先，我们要确定有多少个可选项，我们以**Java**举例，一个`int`是4个**8位**，那么逻辑上它就能存储**4*8个选项值**。

比如我们有一个**星期配置**，用来存储选择的星期数，那么我们可以指定**第一位表示星期一**，**第二位表示星期二**，依次类推。因此如果我们有这样一个数`5`，那么字节展开就是`00000101`，我们就知道我们选择了**星期一**和**星期三**。

## 位运算

有了存储逻辑，我们现在就需要把选项**存入**和**取出**了。

### 存入

还是拿**星期配置**来举例，我们可以计算出每个星期数的存储值：

| 星期数 | 存值 |
| --- | --- |
| 星期一 | 1 |
| 星期二 | 2 |
| 星期三 | 4 |
| 星期四 | 8 |
| 星期五 | 16 |
| 星期六 | 32 |
| 星期日 | 64 |

那么我们是不是就可以在选择了**星期一**之后让星期配置`+1`，选择了**星期三**之后让星期配置`+3`呢？可以，但是这样不好。

我们设想另一个场景，现在有人丢给你了一个星期配置，说这个是默认的配置，你**只能在默认配置的基础上进行增加**。这时如果我们还是简单地增加星期配置值的话，必然会有**重复增加**的情况，此时的星期配置值就会出错。当然我们可以通过默认配置的值来推算出已经选择的是有哪些星期数，然后对他们进行排除避免重复增加，但是很显然这样做并不方便。

那么我们能不能在已经有星期一的情况下，继续增加星期一而让星期配置保持不变呢？就像下面这样：

```text
00000001
00000001
-----------
00000001
```

`1`和`1`做运算得`1`，`0`和`0`做运算得`0`？没错，**与运算**和**或运算**都可以得到这一结果，但是这两个我们都可以用吗？我们来试试下面一个例子，此时我们星期配置中存储了**星期一和星期三**，再**增加星期一**的话我们期望的结果还是**星期一和星期三**：

```text
00000101
00000001
-----------
00000101
```

在这里我们增加了一个条件，`0`和`1`运算得`1`，那么结果就很明显了，只能是**或运算**。

在代码中，我们就可以这样来进行星期配置：

```java
// 星期配置
private static int weeks;

public static void main(String[] args) throws Exception {
    allowedWeek(1); // 增加星期一
    System.out.println(weeks);
    allowedWeek(4 | 8); // 增加星期三和星期四
    System.out.println(weeks);
    allowedWeek(1); // 增加星期三
    System.out.println(weeks);
}

public static void allowedWeek(int week) {
    weeks = weeks | week;
}
```

得出得结果就是：

```text
1
5
13
```

我们现在能通过**或运算**增加星期数，那么该怎么删除星期数呢？按照之前的思路，我们可以构建出下面的运算式，星期配置中存在有**星期一和星期三**，我们在**去除星期一**后只留下了**星期三**：

```text
00000101
00000001
-----------
00000100
```

这里看起来好像**异或**就可以解决，但是如果我们再给定条件：在星期配置中存在**星期一和星期三**的情况下**去除星期一和星期天**，此时我们期望得到的就应该只有**星期三**，但是如果是**异或**的话，结果就变成了：

```text
00000101
01000001
-----------
01000100
```

这里剩下了**星期一**与**星期天**，明显不是我们所期望的结果。

从运算过程可以看出，`1`和`1`运算得`0`，`1`和`0`运算得`1`或是`0`，`0`和`0`运算得`0`，这里我们是找不到运算符的。那么我们可以换个思路：**去除星期一和星期天**也就是**其他星期数是允许的**，那么也就是只要**原有星期数与现在允许的星期数取交集**就可以得到了期望结果：

```text
000000101
110111110
------------
000000100
```

那么我们可以增加一个删除星期数的方法：

```java
public static void blockedWeek(int week) {
    weeks = weeks & ~week;
}
```

### 取出

很好，现在我们已经可以存储星期数配置了，那么我们怎么能从星期数配置中判断某个星期数是被选择的呢？实际上，**或运算**和**与运算**都可以实现选项匹配，匹配方式不同：

- **或运算**中，`配置 | 判断项 = 配置`时，表示判断项在配置中都存在。
- **与运算**中，`配置 & 判断项 = 判断项`时，表示判断项在配置中都存在。

写在代码中就像这样：

```java
public static boolean weekOk(int week) {
    return (weeks & week) == week;
    // return (weeks | week) == weeks;
}
```

## 综述

最终我们通过不同的**位运算**就可以只使用一个`int`类型参数完成多选项的**星期配置**了：

```java
allowedWeek(1); // 增加星期一
System.out.println(weeks); // output：1
System.out.println(weekOk(1)); // 是否存在星期一，output：true
System.out.println(weekOk(4)); // 是否存在星期三，output：false
allowedWeek(4); // 增加星期三
System.out.println(weeks); // output：5
System.out.println(weekOk(1)); // 是否存在星期一，output：true
System.out.println(weekOk(4)); // 是否存在星期三，output：true
allowedWeek(4 | 8); // 增加星期三和星期四
System.out.println(weeks); // output：13
System.out.println(weekOk(4)); // 是否存在星期三，output：true
System.out.println(weekOk(8)); // 是否存在星期四，output：true
blockedWeek(4); // 删除星期三
System.out.println(weeks); // output：9
System.out.println(weekOk(1)); // 是否存在星期一，output：true
System.out.println(weekOk(4)); // 是否存在星期三，output：false
```