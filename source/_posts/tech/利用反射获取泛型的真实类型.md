---
title: 利用反射获取泛型的真实类型
tags:
  - Java
  - 泛型
published: true
abbrlink: 34309
date: 2023-02-28 14:02:53
category:
	- 技术
---
众所周知，泛型的本质是强制类型转换，也就是说在编译后，所有的泛型都会变成是`Object`，并由编译器自动追加类型转换方法。这里就不过多介绍泛型，以下内容默认读者对泛型和反射有一定的了解。

因为泛型的擦除机制，导致在编译后我们无法从一个带泛型的类上直接获取到其泛型，所以本文旨在讨论对属性、方法和类的泛型获取。

## 举例

例如我们有两个类`TestA`和`TestB`：

```java
public class TestA<T> {

    private T t;

    public T getT() { return t; }

    public void setT(T t) { this.t = t; }

    public T test(Integer a, Map<String, Class<?>> map) { return null; }
}

public class TestB extends TestA<String> {
}
```

对于`TestB`，我们可以通过`TestB.class.getGenericSuperclass()`来获取到其父类`TestA`和其泛型`java.lang.String`，但如果想要获取到属性**t**的类型，则需要进行泛型匹配，因为属性**t**是`TestA`中的，如果使用`TestA.class.getDeclaredField("t")`来获取属性，此时会得到一个`Object`类型的属性。

![属性参数](/images/1706076307613.png)

你可以认为我们可以从`TestB.class.getGenericSuperclass()`中解析出泛型，用来匹配属性**t**，这对于一个泛型的类是没有问题的，但是对于多个泛型，例如`Map<K, V>`则无法操作。因为你无法判断属性**t**对应的是哪一个真实类型，我们现在就来讨论如何匹配泛型与真实类型。

## 寻找泛型标记

可以发现**field**有一个属性**signature**，是一个字符串类型，从源码中可以发现这是一个`String`类型的属性。

![Field类](/images/1706076379241.png)

这里的**signature**翻译过来叫做签名，不过不同于方法签名，这个属性并不是用来标记属性的，而是用来标记泛型的。

但是我们从`TT;`这三个字符中似乎看不出泛型信息，没关系，我们可以来看看另一个**signature**。

![方法签名](/images/1706076425924.png)

这就是方法的签名，这个就很明显了，括号内部的表示方法的参数，括号右边的表示了返回值。那么为什么返回值是`TT;`而不是像参数那样直接写明类全名呢？因为`test`方法本身的返回值就是一个泛型，而这个泛型在`TestA`中是未定义具体类型的。

另外这里补充一点，`TT;`的第一个字符表示了类型，**L**表示类，**T**表示泛型，最后一位的分号用于分割参数的，那么中间的符号其实就很好分辨了，这个**T**就是`TestA`类上的泛型参数**T**。

现在要做的就是找到`TestA`上的参数**T**的真实类型，这个真实类型就是属性**t**的真实类型。

## 匹配真实类型

因为`TestA`的泛型是在`TestB`中定义的，所以我们应该从`TestB.class`来寻找。很幸运，在`testB.getClass().getGenericSuperclass()`中，我们找到了一个属性`actualTypeArguments`，这是一个数组，里面存放了定义了的数个泛型。

![真实类型参数列](/images/1706076467631.png)

那么这个属性就能对应上泛型**T**了吗？的确是可以的。但是如果此时我们有两个泛型`<T, V>`，那么`actualTypeArguments`属性就会有两个值，那么哪一个才是我们需要的呢？这时我们就需要知道`<T, V>`和`actualTypeArguments`的对应关系。而这个对应关系我们可以从`TestA.class`中找到，因为泛型是在`TestA`中定义的。

在`Class`的属性中，我们找到了一个属性——`genericInfo`，从名字上看很像是我们寻找的泛型信息，事实上它的确是。在`genericInfo`中存放了名为`typeParams`的数组，这个数组就是`TestA`定义的泛型数组，明确其中的名称就是`T`。

![类型参数对应](/images/1706076520837.png)

也就是说，我们可以从定义泛型的类中找到泛型定义信息，并与泛型实例化类的真实泛型信息做匹配，这样我们就得到了一个泛型标签映射表，用来匹配其中的所有泛型。

## 总结

尽管`Java`在编译后会擦除泛型，但在`Class`、`Field`、`Method`中保存了泛型信息，我们可以通过一些相关的属性找回泛型信息。不要拘泥于`public`方法，要多去看源码，很有可能你的想法能用另一种方式来实现。

相关的代码我写成了一个工具类，放在了 [Github](https://github.com/Verlif/reflection-kit) 上，有兴趣的可以看一看。