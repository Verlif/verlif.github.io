---
title: 一些方便开发和维护的规范
tags:
  - 规范
published: false
abbrlink: 39967
date: 2024-12-18 16:03:54
---

好的设计必定是需要花费更多的时间的，有经验的开发者只是花费的时间更少罢了。对于设计与实施的时间比例是一款产品诞生之初就应该考虑的。

<!-- more -->

## 注释

### 属性

#### 关联其他对象的属性

常见的比如`fileId`、`userId`这类表示了其他对象的ID参数的属性，通常可以通过属性名称直接判断出关联方式。

但是对于某些例如`fileType`这类的属性，尽管可以从名称中看出与文件类型相关，但无法直观地表现出具体的关联关系，因此我们可以在属性注释中这样描述：

```java
/**
 * 文件类型<br/>
 * 与 {@link idea.verlif.test.FileType#getKey()} 对应
 */
private String fileType;
```

在属性注释中表明此字段的来源与关联，方便其他开发者使用。

#### 常量类型属性

常量类属性的命名我们通常与常量类名对应，例如：

```java
private static class Test {
    /**
     * 文件类型<br/>
     * 与 {@link idea.verlif.test.FileType} 对应
     */
    private String fileType;
}

private interface FileType {
    String IMG = "img";
}
```

这样我们可以很好地知道`fileType`属性需要使用`FileType`中的常量，避免属性混乱。

#### 枚举类型属性

与常量类型属性相似，但我们通常会在枚举类中添加反向方法来将fileType的变量值变为FileType中的枚举值：

```java
private static class Test {
    /**
     * 文件类型<br/>
     * 与 {@link idea.verlif.test.FileType} 对应
     */
    private String fileType;
}

private enum FileType {
    IMG("img"),
    ;
    
    private final String key;
    
    FileType(String key) {
        this.key = key;
    }
    
    public String getKey() {
        return key;
    }
    
    public static FileType byKey(String key) {
        for (FileType value : values()) {
            if (Objects.equals(value.key, key)) {
                return value;
            }
        }
        return null;
    }
}
```

这样我们就可以通过byKey方法获取对应的枚举类型了：

```java
Test test = new Test();
FileType fileType = FileType.byKey(test.getFileType());
```

当然，通常情况下，如果枚举类型有包括 *【默认】* 或是 *【其他】* 这种概念的值时，`byKey`方法可以在最后不返回`null`而是返回**默认类型**来减少可能的逻辑错误。

### 方法

#### 入参默认值

一个方法的名字表示了方法的功能，而方法入参表示了这个方法需要的参数。

对于配置类型的参数，通常情况下都是可选的，我们就会使用一个`Config`类进行封装，并重载方法使其作为可选参数进入方法中。

举例：

```java
/**
 * mock数据
 *
 * @param t   对象实例
 * @param <T> 目标泛型
 * @return 返回对象本身
 */
public <T> T mock(T t) {
    return mock(t, new DefaultMockDataConfig());
}

/**
 * mock数据
 *
 * @param t      对象实例
 * @param config 使用的配置
 * @param <T>    目标泛型
 * @return 返回对象本身
 */
public <T> T mock(T t, MockDataConfig config) {
    Creator creator = new Creator(config);
    creator.mock(t, ReflectUtil.getClassGrc(t.getClass()));
    creator.counterClear();
    return t;
}
```

这里的`MockDataConfig`作为可选参数，我们就应该提供一个无需传入的缺省方法供使用者调用，而不是期待使用者传入`null`。

当然，重载的目的是为了调用者能更好地使用适合的入参形式，这并不是必须的，但如果不这样做的话就需要在方法注释中**写明**参数要求。

#### 入参项规范

一个公共方法的入参必须是能包括此方法必要参数的

### 类

#### 接口的使用

##### 使用情形

首先必须要明确一点，接口作为一个抽象类，其作用是耦合逻辑。

通常我们需要用到接口的地方，有以下几种情形：

- 解耦逻辑实现，比如方法的实现方式有多种时，可以通过接口与实现的方式进行具体实现解耦
- 代码隔离，通常在不同模块间进行隔离开发时，我们需要通过接口的方式进行跨模块调用
- 方法规范与预留，某些功能的优先级并不高，且方案暂定时，我们就会先定义方法的接口，便于后期补充实现及切换

##### 对分支开发的好处

实际上，我们在进行分支开发的时候，接口几乎是最好的避免代码冲突的工具。

举例来说，我们此时需要一个文件存储相关的功能，由于某些原因我们需要新增文件存储的分支进行开发，待开发完毕后再合并如主分支。

此时我们需要的是以下步骤：

- 定义出文件存储接口`FileStorageService`
- 编写一个空白实现的实现类`FileStorageServiceImpl`
- 将写好的两个文件提交到主分支
- 从刚才的提交处分离出文件存储开发分支`dev-file-storage`

这样既不会因为文件存储的开发影响主分支，也不会影响到需要用到文件存储的功能开发。

## 代码层级

### 业务分层

对于单体项目来说，我们通常会按照功能或是模块来做代码分隔，因此我们为了能达到模块间调用的能力，就会进行逻辑分层。

例如比较经典的web应用就会分为以下层级：

```text
Controller -> Application -> Service -> Mapper
```

- `Controller`作为api入口，不做业务逻辑书写，直调`Application`方法。
- `Application`作为一个操作的集合，其中的每个方法对应了一个操作。
- `Service`只负责对`Mapper`进行管理，例如`Mapper`入参与出参的**校验**或是**修饰转换**。

那么在模块之间就可以根据需要，来引入其他模块的`Application`或是`Service`

## 三方包引入

### 解耦合

我们在引入其他包作为功能实现时，通常需要注意耦合问题。

除非是绑定包（例如底层逻辑或是框架类型包），否则都建议通过**中间接口**的方式进行引入包调用。

例如，现在我们要开发一套在线文档的功能，我们目前有A、B和C三个在线文档框架可以使用。通过讨论与调研，我们选择了A框架。

此时，我们最好是在业务调用A框架代码前，先建立一个接口文件，我们通过接口方法来代理调用A框架的逻辑。这样可以有效降低A框架在升级时附带的兼容问题的处理难度，并且在某些情况下，我们也可以非常方便地换用B框架。